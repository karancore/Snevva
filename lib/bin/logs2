import 'dart:convert';

import 'package:alarm/alarm.dart';
import 'package:alarm/model/alarm_settings.dart';
import 'package:alarm/model/notification_settings.dart';
import 'package:alarm/model/volume_settings.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:hive/hive.dart';
import 'package:intl/intl.dart';
import 'package:snevva/Controllers/Reminder/reminder_controller.dart';
import 'package:snevva/common/global_variables.dart';
import 'package:snevva/consts/consts.dart';
import 'package:snevva/models/hive_models/reminder_payload_model.dart';

import '../../common/custom_snackbar.dart';
import '../../models/water_reminder_model.dart';

class WaterController extends GetxController {
  var waterReminderOption = Option.times.obs;
  final everyHourController = TextEditingController();
  final timesPerDayController = TextEditingController();
  final startWaterTimeController = TextEditingController();
  final endWaterTimeController = TextEditingController();
  var waterList = <WaterReminderModel>[].obs;
  var savedTimes = 0.obs;
  final everyXhours = 1.obs;

  final startWaterTime = Rx<TimeOfDay?>(null);
  final endWaterTime = Rx<TimeOfDay?>(null);

  ReminderController get reminderController =>
      Get.find<ReminderController>(tag: 'reminder');

  @override
  void onInit() {
    super.onInit();
    print("üíß WaterController initialized");
  }

  void resetForm() {
    // ---------- Text controllers ----------
    everyHourController.clear();
    timesPerDayController.clear();
    startWaterTimeController.clear();
    endWaterTimeController.clear();

    // ---------- Rx values ----------
    waterReminderOption.value = Option.times;
    savedTimes.value = 0;
    everyXhours.value = 1;

    startWaterTime.value = null;
    endWaterTime.value = null;

    // ---------- Local state ----------
    waterList.clear(); // optional: remove if you want to keep loaded reminders
  }

  Future<void> initialiseWaterReminder() async {
    if (savedTimes.value > 0) {
      final todayTimes = generateTimesBetween(
        startTime: startWaterTimeController.text,
        endTime: endWaterTimeController.text,
        times: savedTimes.value,
      );

      // Find next time today
      DateTime? nextTime;
      for (final time in todayTimes) {
        if (time.isAfter(now)) {
          nextTime = time;
          break;
        }
      }

      // If no time left today ‚Üí first time tomorrow
      nextTime ??= todayTimes.first.add(const Duration(days: 1));

      print("üîÑ Scheduling next water alarm at $nextTime");

      final newAlarm = AlarmSettings(
        id: alarmsId(),
        dateTime: nextTime,
        assetAudioPath: alarmSound,
        loopAudio: false,
        androidFullScreenIntent: true,
        volumeSettings: VolumeSettings.fade(
          volume: 0.8,
          fadeDuration: const Duration(seconds: 5),
          volumeEnforced: true,
        ),
        notificationSettings: NotificationSettings(
          title:
              reminderController.titleController.text.isNotEmpty
                  ? reminderController.titleController.text
                  : 'WATER REMINDER',
          body:
              reminderController.notesController.text.isNotEmpty
                  ? reminderController.notesController.text
                  : 'Time to drink water!',
          stopButton: 'Stop',
          icon: 'alarm',
          iconColor: AppColors.primaryColor,
        ),
      );

      await Alarm.set(alarmSettings: newAlarm);
    }
  }

  Future<bool> validateAndSaveWaterReminder(BuildContext context) async {
    if (startWaterTimeController.text.isEmpty) {
      CustomSnackbar.showError(
        context: context,
        title: 'Error',
        message: 'Please enter start time',
      );
      return false;
    }

    if (endWaterTimeController.text.isEmpty) {
      CustomSnackbar.showError(
        context: context,
        title: 'Error',
        message: 'Please enter end time',
      );
      return false;
    }

    if (waterReminderOption.value == Option.interval) {
      // Interval mode
      final intervalHours = int.tryParse(everyHourController.text) ?? 0;
      if (intervalHours <= 0) {
        CustomSnackbar.showError(
          context: context,
          title: 'Error',
          message: 'Please enter a valid hours interval',
        );
        return false;
      }

      final start = stringToTimeOfDay(startWaterTimeController.text);
      final end = stringToTimeOfDay(endWaterTimeController.text);

      final reminders = generateEveryXHours(
        start: start,
        end: end,
        intervalHours: intervalHours,
      );

      if (reminders.isEmpty) {
        return false;
      }
      final body = reminderController.notesController.text.trim();
      setIntervalReminders(
        intervalReminders: reminders,
        context: context,
        title: 'Water',
        intervalHours: intervalHours,
        body: body.isNotEmpty ? body : '',
      );
      return true;
    }
    if (waterReminderOption.value == Option.times) {
      // Times-per-day mode
      final times = int.tryParse(timesPerDayController.text) ?? 0;
      if (times <= 0) {
        CustomSnackbar.showError(
          context: context,
          title: 'Error',
          message: 'Please enter a valid number of times per day',
        );
        return false;
      }
      await setWaterAlarm(times: times, context: context);
      return true;
    }
    return false;
  }

  Future<void> setWaterAlarm({
    required int? times,
    required BuildContext context,
  }) async {
    if (times == null || times <= 0) {
      CustomSnackbar.showError(
        context: context,
        title: 'Error',
        message: 'Please enter a valid number of times per day',
      );
      return;
    }

    final alarmTimes = generateTimesBetween(
      startTime: startWaterTimeController.text,
      endTime: endWaterTimeController.text,
      times: times,
    );

    List<AlarmSettings> createdAlarms = [];

    for (var i = 0; i < alarmTimes.length; i++) {
      final time = alarmTimes[i];
      final scheduledTime =
          time.isBefore(DateTime.now()) ? time.add(Duration(days: 1)) : time;

      final alarmId = alarmsId();
      final alarmSettings = AlarmSettings(
        id: alarmId,
        dateTime: scheduledTime,
        assetAudioPath: alarmSound,
        loopAudio: false,
        androidFullScreenIntent: true,
        volumeSettings: VolumeSettings.fade(
          volume: 0.8,
          fadeDuration: Duration(seconds: 5),
          volumeEnforced: true,
        ),
        notificationSettings: NotificationSettings(
          title:
              reminderController.titleController.text.isNotEmpty
                  ? reminderController.titleController.text
                  : 'WATER REMINDER',
          body:
              reminderController.notesController.text.isNotEmpty
                  ? reminderController.notesController.text
                  : 'Time to drink water!',
          stopButton: 'Stop',
          icon: 'alarm',
          iconColor: AppColors.primaryColor,
        ),
      );

      await Alarm.set(alarmSettings: alarmSettings);
      createdAlarms.add(alarmSettings);
    }

    final waterReminderId = DateTime.now().millisecondsSinceEpoch;

    final model = WaterReminderModel(
      id: waterReminderId,
      title:
          reminderController.titleController.text.isNotEmpty
              ? reminderController.titleController.text
              : 'WATER REMINDER',
      alarms: createdAlarms,
      waterReminderStartTime: startWaterTimeController.text.trim(),
      waterReminderEndTime: endWaterTimeController.text.trim(),
      notes: reminderController.notesController.text.trim(),
      type: Option.times,
      timesPerDay: times.toString(),
      category: "Water",
    );

    // Reload list from Hive to ensure we have the latest data and don't override
    waterList.value = await loadWaterReminderList("water_list");

    waterList.add(model);

    savedTimes.value = times;

    await reminderController.saveReminderList(waterList, "water_list");
    await reminderController.loadAllReminderLists();

    List<String> list =
        createdAlarms.map((e) => e.toJson().toString()).toList();

    // final waterData = {
    //   "id": waterReminderId,
    //   "category": "WATER",
    //   "title": model.title,
    //   "notes": reminderController.notesController.text,
    //   "reminderType": "times",
    //   "startTime": startWaterTimeController.text,
    //   "endTime": endWaterTimeController.text,
    //   "timesPerDay": times,
    //   "intervalHours": null,
    //   "isActive": true,
    // };

    final waterData = ReminderPayloadModel(
      id: waterReminderId,
      category: ReminderCategory.water.toString(),
      title: model.title,
      notes: reminderController.notesController.text,
      reminderFrequencyType: Option.times.toString(),
      customReminder: CustomReminder(
        timesPerDay: TimesPerDay(count: times.toString(), list: list),
      ),
      startWaterTime: startWaterTimeController.text.trim(),
      endWaterTime: endWaterTimeController.text.trim(),
    );

    print("Water Data setWaterAlarm: $waterData");

    //reminderController.addRemindertoAPI(waterData, context);

    CustomSnackbar().showReminderBar(context);
    Get.back(result: true);
  }

  List<DateTime> generateTimesBetween({
    required String startTime,
    required String endTime,
    required int times,
  }) {
    if (times <= 0) return [];

    final start = DateFormat('hh:mm a').parse(startTime);
    final end = DateFormat('hh:mm a').parse(endTime);

    DateTime startDT = DateTime(
      now.year,
      now.month,
      now.day,
      start.hour,
      start.minute,
    );

    DateTime endDT = DateTime(
      now.year,
      now.month,
      now.day,
      end.hour,
      end.minute,
    );

    // Handle overnight range
    if (endDT.isBefore(startDT)) {
      endDT = endDT.add(const Duration(days: 1));
    }

    final totalMinutes = endDT.difference(startDT).inMinutes;
    const int minGapMinutes = 1;

    final gap = (totalMinutes / times).floor();

    if (gap < minGapMinutes) {
      debugPrint("Not enough time to schedule $times reminders.");
      debugPrint('totalMinutes=$totalMinutes, times=$times, gap=$gap');
    }

    return List.generate(times, (i) {
      return startDT.add(Duration(minutes: gap * i));
    });
  }

  List<DateTime> generateEveryXHours({
    required TimeOfDay start,
    required TimeOfDay end,
    required int intervalHours,
  }) {
    if (intervalHours <= 0) {
      return [];
    }

    final window = buildTimeWindow(start, end);

    final reminders = <DateTime>[];
    DateTime current = window.start;

    int counter = 0;

    while (!current.isAfter(window.end)) {
      reminders.add(current);

      final next = current.add(Duration(hours: intervalHours));

      current = next;
      counter++;

      // Safety guard (prevents infinite loops in debug)
      if (counter > 100) {
        break;
      }
    }
    return reminders;
  }

  Future<void> onWaterAlarmRang(int rangAlarmId) async {

    final reminderController = Get.find<ReminderController>();

    /// Load from your existing function
    List<Map<String, AlarmSettings>> list =
    await reminderController.loadReminderList("water_list");

    for (int i = 0; i < list.length; i++) {

      final map = list[i];

      for (final entry in map.entries) {

        final String title = entry.key;
        final AlarmSettings alarm = entry.value;

        /// FOUND the alarm that rang
        if (alarm.id == rangAlarmId) {

          debugPrint("üö∞ Found rang water alarm: $rangAlarmId ($title)");

          /// IMPORTANT: stop previous instance
          await Alarm.stop(rangAlarmId);

          /// Calculate next day same time
          DateTime nextTime = DateTime(
            DateTime.now().year,
            DateTime.now().month,
            DateTime.now().day,
            alarm.dateTime.hour,
            alarm.dateTime.minute,
          ).add(const Duration(days: 1));

          if (nextTime.isBefore(DateTime.now())) {
            nextTime = nextTime.add(const Duration(days: 1));
          }

          /// Create new alarm
          final newAlarm = AlarmSettings(
            id: rangAlarmId, // reuse SAME id
            dateTime: nextTime,
            assetAudioPath: alarm.assetAudioPath,
            loopAudio: true,
            vibrate: true,
            volumeSettings: alarm.volumeSettings,
            notificationSettings: alarm.notificationSettings,
          );

          /// Schedule again
          await Alarm.set(alarmSettings: newAlarm);

          /// Replace inside map
          list[i][title] = newAlarm;

          /// Convert back to JSON string list (VERY IMPORTANT)
          final List<String> encoded = list.map((mapItem) {
            final encodedMap = mapItem.map(
                  (k, v) => MapEntry(k, v.toJson()),
            );
            return jsonEncode(encodedMap);
          }).toList();

          /// Save back to Hive
          final box = Hive.box('reminders_box');
          await box.put("water_list", encoded);

          debugPrint("üîÅ Water alarm rescheduled for $nextTime");

          return;
        }
      }
    }

    debugPrint("‚ö†Ô∏è Rang alarm not found in water_list: $rangAlarmId");
  }



  Future<void> setIntervalReminders({
    required List<DateTime> intervalReminders,
    required int intervalHours,
    BuildContext? context,
    required String title,
    required String body,
  }) async {
    final start = stringToTimeOfDay(startWaterTimeController.text);
    final end = stringToTimeOfDay(endWaterTimeController.text);
    for (var reminderTime in intervalReminders) {
      final alarmSettings = AlarmSettings(
        id: alarmsId(),
        dateTime: reminderTime,
        notificationSettings: NotificationSettings(
          title:
              reminderController.titleController.text.isNotEmpty
                  ? reminderController.titleController.text
                  : '$title reminder',
          body: body,
          stopButton: 'Stop',
          icon: 'alarm',
          iconColor: AppColors.primaryColor,
        ),
        androidFullScreenIntent: true,
        payload: jsonEncode({
          "type": "water",
          "interval": intervalHours,
          "start": start,
          "end": end,
        }),

        assetAudioPath: alarmSound,
        volumeSettings: VolumeSettings.fade(
          volume: 0.8,
          fadeDuration: Duration(seconds: 5),
          volumeEnforced: true,
        ),
      );

      await Alarm.set(alarmSettings: alarmSettings);
    }
    final waterReminderId = DateTime.now().millisecondsSinceEpoch;

    final model = WaterReminderModel(
      id: waterReminderId,
      title:
          reminderController.titleController.text.isNotEmpty
              ? reminderController.titleController.text
              : '',
      alarms: [],
      timesPerDay: '',
      notes: reminderController.notesController.text.trim(),
      waterReminderStartTime: startWaterTimeController.text.trim(),
      waterReminderEndTime: endWaterTimeController.text.trim(),
      type: Option.interval,
      interval: '$intervalHours',
      category: "Water",
    );

    // Reload list from Hive to ensure we have the latest data and don't override
    waterList.value = await loadWaterReminderList("water_list");
    waterList.add(model);

    //final waterList = reminderController.waterList;

    await reminderController.saveReminderList(waterList, "water_list");

    await reminderController.loadAllReminderLists();

    // final waterData = {
    //   "id": waterReminderId,
    //   "category": "WATER",
    //   "title": model.title,
    //   "notes": reminderController.notesController.text,
    //   "reminderType": "interval",
    //   "startTime": startWaterTimeController.text,
    //   "endTime": endWaterTimeController.text,
    //   "timesPerDay": null,
    //   "intervalHours": intervalHours,
    //   "isActive": true,
    // };

    print("startWaterTimeController ${startWaterTimeController.text.trim()}");
    print("endWaterTimeController ${endWaterTimeController.text.trim()}");

    final waterData = ReminderPayloadModel(
      id: waterReminderId,
      category: "WATER",
      title: model.title,
      notes: reminderController.notesController.text,
      reminderFrequencyType: Option.interval.toString(),
      customReminder: CustomReminder(
        everyXHours: EveryXHours(
          hours: intervalHours,
          startTime: startWaterTimeController.text,
          endTime: endWaterTimeController.text,
        ),
      ),
      startWaterTime: startWaterTimeController.text.trim(),
      endWaterTime: endWaterTimeController.text.trim(),
    );
    print("Water Data setIntervalReminders: $waterData");

    // reminderController.addRemindertoAPI(waterData, context);

    if (context != null) {
      CustomSnackbar().showReminderBar(context);
    }
    Get.back(result: true);
  }

  DateTime? _calculateNextWaterAlarm(int intervalHours) {
    final startTime = startWaterTimeController.value; // e.g., 8:00 AM
    final endTime = startWaterTimeController.value; // e.g., 10:00 PM

    if (startTime != null && endTime != null) {
      // Convert to DateTime
      DateTime startDateTime = DateTime(now.year, now.month, now.day);
      DateTime endDateTime = DateTime(now.year, now.month, now.day);
      // Handle overnight window (e.g., 10 PM to 2 AM)
      if (endDateTime.isBefore(startDateTime)) {
        endDateTime = endDateTime.add(Duration(days: 1));
      }
      // Calculate next alarm
      DateTime nextAlarm = now.add(Duration(hours: intervalHours));

      // SCENARIO 1: Current time is BEFORE start time today
      if (now.isBefore(startDateTime)) {
        nextAlarm = startDateTime; // Set to start time today
      } // SCENARIO 2: Next alarm would be AFTER end time today
      else if (nextAlarm.isAfter(endDateTime)) {
        nextAlarm = startDateTime.add(Duration(days: 1)); // Tomorrow's start
      }
      // SCENARIO 3: Current time is AFTER end time today
      else if (now.isAfter(endDateTime)) {
        nextAlarm = startDateTime.add(Duration(days: 1)); // Tomorrow's start
      }

      return nextAlarm;
    } else {
      debugPrint('Invalid water time window');
      return null;
    }
  }

  DateTimeRange getActiveWindow() {
    final start = combineWithToday(startWaterTime.value!);
    var end = combineWithToday(endWaterTime.value!);

    // Overnight window (e.g. 10 PM ‚Üí 6 AM)
    if (end.isBefore(start)) {
      end = end.add(const Duration(days: 1));
    }

    return DateTimeRange(start: start, end: end);
  }

  Duration _waterDuration() {
    DateTime start = parseWaterTime(startWaterTimeController.text);
    DateTime end = parseWaterTime(endWaterTimeController.text);

    if (end.isBefore(start)) {
      end = end.add(const Duration(days: 1));
    }

    return end.difference(start);
  }

  DateTime parseWaterTime(String time) {
    final parsed = DateFormat('hh:mm a').parse(time);

    return DateTime(now.year, now.month, now.day, parsed.hour, parsed.minute);
  }

  Future<void> updateWaterReminderFromLocal(
    BuildContext context,
    String id,
    int? times,
  ) async {
    try {
      final index = waterList.indexWhere((e) => e.id == id);

      if (index != -1) {
        final oldModel = waterList[index];

        for (var alarm in oldModel.alarms) {
          await Alarm.stop(alarm.id);
        }

        waterList.removeAt(index);
        await reminderController.saveReminderList(waterList, "water_list");
      }

      await setWaterAlarm(times: times, context: context);
    } catch (e) {
      throw Exception("Error updating WATER reminder: $e");
    }
  }

  Future<List<WaterReminderModel>> loadWaterReminderList(String keyName) async {
    final box = Hive.box('reminders_box');
    final List<dynamic>? storedList = box.get(keyName);

    if (storedList == null) {
      return [];
    }

    final List<String> stringList = storedList.cast<String>();
    List<WaterReminderModel> loadedList = [];

    for (var i = 0; i < stringList.length; i++) {
      final item = stringList[i];

      try {
        final Map<String, dynamic> decoded = jsonDecode(item);

        if (decoded.containsKey('timesPerDay')) {
          final model = WaterReminderModel.fromJson(decoded);
          loadedList.add(model);
        } else {
          final entry = decoded.entries.first;
          final fallbackModel = WaterReminderModel(
            title: entry.key,
            id: alarmsId(),
            alarms: [],
            notes: reminderController.notesController.text.trim(),
            type: waterReminderOption.value,
            timesPerDay: timesPerDayController.text,
            category: "Water",
            waterReminderStartTime: startWaterTimeController.text.trim(),
            waterReminderEndTime: endWaterTimeController.text.trim(),
          );

          loadedList.add(fallbackModel);
        }
      } catch (e, stack) {
        print(' Error parsing water reminder: $e');
        print(stack);
      }
    }
    return loadedList;
  }

  Future<void> deleteWaterReminder(int id) async {
    debugPrint('üóëÔ∏è deleteWaterReminder called with id=$id');

    int index = -1;

    for (int i = 0; i < waterList.length; i++) {
      debugPrint(
        'üîç Checking waterList[$i] ‚Üí storedId=${waterList[i].id} '
        '(type=${waterList[i].id.runtimeType})',
      );

      if (waterList[i].id == id) {
        index = i;
        break;
      }
    }

    if (index != -1) {
      debugPrint('‚úÖ Water reminder found at index=$index');

      for (var alarm in waterList[index].alarms) {
        debugPrint('‚èπÔ∏è Stopping alarm id=${alarm.id}');
        await Alarm.stop(alarm.id);
      }

      waterList.removeAt(index);
      debugPrint('üóëÔ∏è Removed water reminder. Remaining=${waterList.length}');

      await reminderController.saveReminderList(waterList, "water_list");
      debugPrint('üíæ Water list saved to Hive');
    } else {
      debugPrint('‚ùå No water reminder found with id=$id');
    }
  }

  void resetControllers() {
    everyHourController.clear();
    timesPerDayController.clear();

    startWaterTimeController.clear();
    endWaterTimeController.clear();
    savedTimes.value = 0;
    startWaterTime.value = null;
    endWaterTime.value = null;
    everyXhours.value = 1;
    waterReminderOption.value = Option.times;
  }

  @override
  void onClose() {
    resetForm();
    super.onClose();
  }
} import 'dart:async';
import 'package:flutter/widgets.dart';
import 'dart:convert';

import 'package:alarm/alarm.dart';
import 'package:alarm/model/alarm_settings.dart';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:permission_handler/permission_handler.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:snevva/Controllers/Reminder/event_controller.dart';
import 'package:snevva/Controllers/Reminder/meal_controller.dart';
import 'package:snevva/Controllers/Reminder/medicine_controller.dart';
import 'package:snevva/Controllers/Reminder/water_controller.dart';
import 'package:snevva/common/custom_snackbar.dart';
import 'package:snevva/consts/consts.dart';
import 'package:snevva/env/env.dart';
import 'package:snevva/models/hive_models/reminder_payload_model.dart'
    as reminder_payload;
import 'package:snevva/services/api_service.dart';

import '../../common/global_variables.dart';
import '../../models/medicine_reminder_model.dart' as medicine_payload;
import '../../models/water_reminder_model.dart';

class ReminderController extends GetxController {
  final titleController = TextEditingController();
  final timeController = TextEditingController();
  final notesController = TextEditingController();
  Rx<TimeOfDay?> waterStartTime = Rx<TimeOfDay?>(TimeOfDay(hour: 8, minute: 0));
  Rx<TimeOfDay?> waterEndTime = Rx<TimeOfDay?>(TimeOfDay(hour: 22, minute: 0));
  Rxn<dynamic> editingId = Rxn<dynamic>();
  final xTimeUnitController = TextEditingController();
  var reminders = <reminder_payload.ReminderPayloadModel>[].obs;
  var alarms = <AlarmSettings>[].obs;
  var isLoading = false.obs;
  final selectedValue = 'minutes'.obs;
  var startDateString = ''.obs;
  var endDateString = ''.obs;

  var selectedDateIndex = 0.obs;

  var remindTimes = <String>[].obs;

  late final WaterController waterController;
  late final MedicineController medicineGetxController;
  late final EventController eventGetxController;

  late final MealController mealController;

  var selectedCategory = 'Medicine'.obs;
  var enableNotifications = true.obs;
  var soundVibrationToggle = true.obs;
  final RxnInt remindMeBefore = RxnInt();
  static const int maxTitleLength = 45;

  Rx<DateTime?> startDate = Rx<DateTime?>(null);
  Rx<DateTime?> endDate = Rx<DateTime?>(null);
  Rx<TimeOfDay?> pickedTime = Rx<TimeOfDay?>(null);

  static StreamSubscription<AlarmSettings>? subscription;
  bool listenerAttached = false;

  final List<String> categories = ['Medicine', 'Water', 'Meal', 'Event'];

  @override
  void onInit() {
    super.onInit();
    waterController = Get.find<WaterController>();
    medicineGetxController = Get.find<MedicineController>();
    mealController = Get.find<MealController>();
    eventGetxController = Get.find<EventController>();
    startDate.value = DateTime.now();
    initAlarmListener();

    startDateString.value = "Start Date";
    endDateString.value = "End Date";

    Future.microtask(() async {
      await checkAndroidNotificationPermission();
      await checkAndroidScheduleExactAlarmPermission();
      await cleanupExpiredBeforeAlarms();
      await loadAlarms();
      await loadAllReminderLists();
    });

    // WidgetsBinding.instance.addPostFrameCallback((_) async {
    //   await loadAlarms();
    //   await loadAllReminderLists();
    // });
  }

  @override
  void onClose() {
    titleController.dispose();
    timeController.dispose();
    notesController.dispose();
    xTimeUnitController.dispose();

    super.onClose();
  }

  // BoxShadow(
  // color: Colors.grey.withOpacity(0.4), // Shadow color
  // spreadRadius: 2, // How widely the shadow spreads
  // blurRadius: 6, // How blurry the shadow is

  // offset: Offset(0, 0), // Horizontal and vertical offset
  // ),

  Future<void> handleRemindMeBefore({
    required RxnInt option,
    required TimeOfDay? timeOfDay,
    required TextEditingController timeController,
    required RxString unitController,
    required String category,
    required String title,
    required String body,
  }) async {
    // 1Ô∏è‚É£ Guard conditions
    if (option.value != 0) {
      return;
    }

    if (timeOfDay == null) {
      return;
    }

    // 3Ô∏è‚É£ Calculate scheduled time
    final now = DateTime.now();

    DateTime scheduledTime = DateTime(
      startDate.value?.year ?? now.year,
      startDate.value?.month ?? now.month,
      startDate.value?.day ?? now.day,
      timeOfDay.hour,
      timeOfDay.minute,
    );

    // 4Ô∏è‚É£ Adjust if in past
    if (scheduledTime.isBefore(now)) {
      scheduledTime = scheduledTime.add(const Duration(days: 1));
    }

    // 5Ô∏è‚É£ Schedule alarm
    setBeforeReminderAlarm(mainTime: scheduledTime, title: title, body: body);
  }

  // ==================== Permission Methods ====================

  Future<void> checkAndroidNotificationPermission() async {
    final status = await Permission.notification.status;
    if (status.isDenied) {
      print('Requesting notification permission...');
      final res = await Permission.notification.request();
      print('Notification permission ${res.isGranted ? '' : 'not '}granted');
    }
    if (status.isGranted) {
      print("Enabled notifications permission ${enableNotifications.value}");
      enableNotifications.value = true;
    }
  }

  Future<void> checkAndroidScheduleExactAlarmPermission() async {
    final status = await Permission.scheduleExactAlarm.status;
    if (kDebugMode) {
      print('Schedule exact alarm permission: $status.');
    }
    if (status.isDenied) {
      if (kDebugMode) {
        print('Requesting schedule exact alarm permission...');
      }
      final res = await Permission.scheduleExactAlarm.request();
      if (kDebugMode) {
        print(
          'Schedule exact alarm permission ${res.isGranted ? '' : 'not'} granted.',
        );
      }
    }
  }

  // ==================== Alarm Listener ====================

  void initAlarmListener() {
    if (subscription != null) return;
    // if (listenerAttached) return;
    // listenerAttached = true;

    // subscription ??= Alarm.ringStream.stream.listen((
    //   AlarmSettings alarmSettings,
    // ) async {
    //   print("ALARM RANG ‚Üí ID: ${alarmSettings.id}");
    //   unawaited(waterController.initialiseWaterReminder());
    // });
    subscription = Alarm.ringStream.stream.listen((AlarmSettings alarmSettings) async {
      print("Alarm rang id : ${alarmSettings.id}");
      if(alarmSettings.payload == null) return;
      final data = jsonDecode(alarmSettings.payload ?? '');
      if(data != null){
        if(data['type'] == 'water') {
          await waterController.onWaterAlarmRang(data);
        }
      }
    });
  }

  // ==================== Alarm Management ====================

  Future<void> loadAlarms() async {
    final loadedAlarms = await Alarm.getAlarms();
    loadedAlarms.sort((a, b) => a.dateTime.compareTo(b.dateTime));
    alarms.value = loadedAlarms;
  }

  Future<void> setBeforeReminderAlarm({
    required DateTime mainTime,
    required String title,
    required String body,
  }) async {
    // 1Ô∏è‚É£ Read inputs
    final amount = int.tryParse(xTimeUnitController.text) ?? 0;
    final unit = selectedValue.value; // "minutes" or "hours"

    // 2Ô∏è‚É£ Calculate offset
    final offset =
        unit == "minutes" ? Duration(minutes: amount) : Duration(hours: amount);

    // 3Ô∏è‚É£ Calculate before time
    DateTime beforeTime = mainTime.subtract(offset);

    // 4Ô∏è‚É£ Adjust if in past
    if (beforeTime.isBefore(DateTime.now())) {
      beforeTime = beforeTime.add(const Duration(days: 1));
    }

    // 5Ô∏è‚É£ Build alarm settings
    final alarmId = alarmsId();
    final alarmSettings = AlarmSettings(
      id: alarmId,
      dateTime: beforeTime,
      assetAudioPath: alarmSound,
      loopAudio: true,
      vibrate: soundVibrationToggle.value,
      androidFullScreenIntent: true,
      notificationSettings: NotificationSettings(
        title: title,
        body: "$body $amount $unit",
        stopButton: "Stop",
        icon: "alarm",
      ),
      payload: jsonEncode({
        "type": "before",
        "category": selectedCategory.value,
        "mainTime": mainTime.toIso8601String(),
      }),
      volumeSettings: VolumeSettings.fade(
        fadeDuration: const Duration(seconds: 2),
      ),
    );

    // 6Ô∏è‚É£ Set alarm
    await Alarm.set(alarmSettings: alarmSettings);
  }

  Future<void> cleanupExpiredBeforeAlarms() async {
    final alarms = await Alarm.getAlarms();
    final now = DateTime.now();
    for (final alarm in alarms) {
      final payload = alarm.payload;
      if (payload == null) continue;
      final decoded = jsonDecode(payload);
      if (decoded['type'] == 'before') {
        final mainTime = DateTime.parse(decoded['mainTime']);
        if (now.isAfter(mainTime)) {
          debugPrint(
            "Cancelling expired before-alarm ${alarm.notificationSettings.title}",
          );
          await Alarm.stop(alarm.id);
        }
      }
    }
  }

  DateTime calculateBeforeReminder() {
    // Parse input time (hh:mm a)
    final selectedTime = parseTime(timeController.text);

    DateTime eventTime = DateTime(
      now.year,
      now.month,
      now.day,
      selectedTime.hour,
      selectedTime.minute,
    );

    int value = int.tryParse(xTimeUnitController.text) ?? 0;

    Duration diff =
        selectedValue.value == "minutes"
            ? Duration(minutes: value)
            : Duration(hours: value);

    DateTime reminderTime = eventTime.subtract(diff);

    // If reminder is in the past ‚Üí move to tomorrow
    if (reminderTime.isBefore(now)) {
      reminderTime = reminderTime.add(Duration(days: 1));
    }

    return reminderTime;
  }

  Future<void> addAlarm(
    BuildContext context, {
    required TimeOfDay timeOfDay,
    required String category,
  }) async {
    var scheduledTime = DateTime(
      startDate.value?.year ?? now.year,
      startDate.value?.month ?? now.month,
      startDate.value?.day ?? now.day,
      timeOfDay.hour,
      timeOfDay.minute,
    );

    if (scheduledTime.isBefore(now) || scheduledTime.isAtSameMomentAs(now)) {
      scheduledTime = scheduledTime.add(Duration(days: 1));
      print('‚ö†Ô∏è Time was in past/now, moved to tomorrow: $scheduledTime');
    }

    switch (category) {
      // case "Medicine":
      //   await medicineGetxController.addMedicineAlarm(scheduledTime, context);
      //   break;
      case "Meal":
        await mealController.addMealAlarm(scheduledTime, context);
        break;
      case "Event":
        await eventGetxController.addEventAlarm(scheduledTime, context);
        break;
    }
    // if (category == 'Event' && remindMeBefore.value == 0) {
    //   final rx =
    //       eventGetxController.eventRemindMeBefore;
    //   rx.value = rx.value == 0 ? null : 0;
    //   await handleRemindMeBefore(
    //     option: rx,
    //     timeOfDay: pickedTime.value,
    //     timeController: xTimeUnitController,
    //     unitController: selectedValue,
    //     category: "Medicine",
    //   );
    //   await setBeforeReminderAlarm(scheduledTime);
    // }
    // if (category == 'Medicine' && remindMeBefore.value == 0) {
    //   final rx =
    //       medicineGetxController.medicineRemindMeBeforeOption;
    //   rx.value = rx.value == 0 ? null : 0;
    //   await handleRemindMeBefore(
    //     option: rx,
    //     timeOfDay: pickedTime.value,
    //     timeController: xTimeUnitController,
    //     unitController: selectedValue,
    //     category: "Medicine",
    //   );
    // }
  }

  Future<void> updateReminderFromLocal(
    BuildContext context, {
    required String id,
    required String category,
    TimeOfDay? timeOfDay,
    int? times,
  }) async {
    print("üöÄ updateReminderFromLocal called");
    print("‚û°Ô∏è id: $id (${id.runtimeType})");
    print("‚û°Ô∏è category: $category");
    print("‚û°Ô∏è timeOfDay: $timeOfDay");
    print("‚û°Ô∏è times: $times (${times.runtimeType})");

    var scheduledTime = DateTime(
      startDate.value?.year ?? now.year,
      startDate.value?.month ?? now.month,
      startDate.value?.day ?? now.day,
      timeOfDay == TimeOfDay.now() ? timeOfDay!.hour : now.hour,
      timeOfDay == TimeOfDay.now() ? timeOfDay!.minute : now.minute,
    );

    print("üïí initial scheduledTime ‚Üí $scheduledTime");

    if (scheduledTime.isBefore(now) || scheduledTime.isAtSameMomentAs(now)) {
      scheduledTime = scheduledTime.add(const Duration(days: 1));
      print("‚è≠Ô∏è time was past ‚Üí moved to $scheduledTime");
    }

    if (category == 'Water') {
      waterController.updateWaterReminderFromLocal(context, id, times);
    } else {
      print("üîÅ Updating single alarm ‚Üí $category with id=$id");

      switch (category) {
        case 'Medicine':
          await medicineGetxController.updateMedicineAlarm(
            scheduledTime,
            context,
            int.parse(id),
          );
          break;
        case 'Meal':
          await mealController.updateMealAlarm(
            scheduledTime,
            context,
            int.parse(id),
          );
          break;
        case 'Event':
          await eventGetxController.updateEventAlarm(
            scheduledTime,
            context,
            int.parse(id),
          );
          break;
        default:
          print("‚ö†Ô∏è Unknown category: $category");
      }
    }

    print("‚úÖ updateReminderFromLocal completed");
  }

  Future<void> finalizeUpdate(
    BuildContext context,
    String key,
    dynamic list,
  ) async {
    titleController.clear();
    notesController.clear();
    medicineGetxController.medicineController.clear();

    await saveReminderList(list, key);
    await loadAllReminderLists();

    CustomSnackbar.showSuccess(
      context: context,
      title: 'Success',
      message: 'Reminder updated successfully!',
    );
    Get.back(result: true);
  }

  Future<void> scheduleAlarmEveryXHours(int intervalHours) async {
    final nextTime = DateTime.now().add(Duration(hours: intervalHours));

    final newAlarm = AlarmSettings(
      id: alarmsId(),
      dateTime: nextTime,
      assetAudioPath: alarmSound,
      androidFullScreenIntent: true,
      loopAudio: true,
      vibrate: soundVibrationToggle.value,
      volumeSettings: VolumeSettings.fade(
        volume: 0.8,
        fadeDuration: Duration(seconds: 5),
        volumeEnforced: true,
      ),
      notificationSettings:
          enableNotifications.value
              ? NotificationSettings(
                title: titleController.text,
                body: notesController.text,
                stopButton: 'Stop',
                icon: 'alarm',
                iconColor: AppColors.primaryColor,
              )
              : NotificationSettings(
                title: 'Water Reminder',

                // FIX: Added default title
                body: 'Time to drink water!',
                // FIX: Added default body
                stopButton: 'Stop',
                icon: 'alarm',
                iconColor: AppColors.primaryColor,
              ),
    );

    await Alarm.set(alarmSettings: newAlarm);
  }

  Future<void> stopAlarm(
    int index,
    AlarmSettings alarm,
    dynamic reminderList,
  ) async {
    await Alarm.stop(alarm.id);
    reminderList.removeAt(index);
    String listKey = _getListKeyFromType(reminderList);
    if (listKey.isNotEmpty) {
      await saveReminderList(reminderList, listKey);
    }
  }

  String _getListKeyFromType(RxList<Map<String, AlarmSettings>> list) {
    if (identical(list, medicineGetxController.medicineList))
      return "medicine_list";
    if (identical(list, mealController.mealsList)) return "meals_list";
    if (identical(list, eventGetxController.eventList)) return "event_list";
    if (identical(list, waterController.waterList)) return "water_list";
    return "";
  }

  Future<void> deleteReminder(
    reminder_payload.ReminderPayloadModel reminder,
  ) async {
    final id = reminder.id;
    final category = reminder.category;

    debugPrint(
      'üóëÔ∏è deleteReminder START ‚Üí '
      'category=$category, id=$id (type=${id.runtimeType})',
    );

    switch (category) {
      case 'Medicine':
        debugPrint('‚û°Ô∏è Deleting Medicine');
        await _deleteFromListById(
          medicineGetxController.medicineList,
          id,
          "medicine_list",
        );
        break;

      case 'Meal':
        debugPrint('‚û°Ô∏è Deleting Meal');
        await _deleteFromListById(mealController.mealsList, id, "meals_list");
        break;

      case 'Event':
        debugPrint('‚û°Ô∏è Deleting Event');
        await _deleteFromListById(
          eventGetxController.eventList,
          id,
          "event_list",
        );
        break;

      case 'Water':
        debugPrint('‚û°Ô∏è Deleting Water');
        //"water_list";
        await waterController.deleteWaterReminder(id);

        break;

      default:
        debugPrint('‚ö†Ô∏è Unknown category: $category');
    }

    debugPrint('üîÑ Reloading all reminder lists');
    await loadAllReminderLists();
    debugPrint('‚úÖ deleteReminder END');
  }

  Future<void> _deleteFromListById(
    RxList<dynamic> list,
    int id,
    String keyName,
  ) async {
    debugPrint('üóëÔ∏è Delete requested ‚Üí id: $id | key: $keyName');
    debugPrint('üì¶ List length: ${list.length}');

    int index = -1;

    for (int i = 0; i < list.length; i++) {
      final item = list[i];
      debugPrint('üîç Checking index $i ‚Üí type: ${item.runtimeType}');

      // Handle Map<String, AlarmSettings>
      if (item is Map<String, AlarmSettings>) {
        final alarmId = item.values.first.id;
        debugPrint('   Map Alarm ID: $alarmId');

        if (alarmId == id) {
          debugPrint('   ‚úÖ Match found at index $i (Map)');
          index = i;
          break;
        }
      }
      // Handle MedicineReminderModel
      else if (item is medicine_payload.MedicineReminderModel) {
        debugPrint('   MedicineReminderModel ID: ${item.id}');

        if (item.id == id) {
          debugPrint('   ‚úÖ Match found at index $i (MedicineReminderModel)');
          index = i;
          break;
        }
      } else {
        debugPrint('   ‚ö†Ô∏è Unknown item type at index $i');
      }
    }

    if (index != -1) {
      debugPrint('üßπ Removing item at index $index');
      await Alarm.stop(id);
      list.removeAt(index);
      await saveReminderList(list, keyName);
      debugPrint('üíæ Item deleted and list saved');
    } else {
      debugPrint('‚ùå No item found with id: $id');
    }
  }

  void addReminderTime() {
    if (timeController.text.isNotEmpty) {
      remindTimes.add(timeController.text);
      timeController.clear();
    }
  }

  void removeReminderTime(int index) {
    remindTimes.removeAt(index);
  }

  // ==================== Hive Methods ====================

  Future<List<Map<String, AlarmSettings>>> loadReminderList(
    String keyName,
  ) async {
    print('üì¶ loadReminderList() ‚Üí key: $keyName');

    final box = Hive.box('reminders_box');
    final List<dynamic>? storedList = box.get(keyName);

    if (storedList == null) {
      print('‚ö†Ô∏è No data found for $keyName');
      return [];
    }

    print('üìÑ Raw list length [$keyName]: ${storedList.length}');

    final List<String> stringList = storedList.cast<String>();

    final result =
        stringList.map((item) {
          print('üîç Decoding item: $item');

          final Map<String, dynamic> decoded = jsonDecode(item);
          final mapped = decoded.map((key, value) {
            print('   ‚ûú Alarm title: $key');
            return MapEntry(key, AlarmSettings.fromJson(value));
          });

          return mapped;
        }).toList();

    print('‚úÖ Loaded ${result.length} alarms for $keyName');
    return result;
  }

  Future<void> saveReminderList(RxList<dynamic> list, String keyName) async {
    print('üíæ Saving reminders ‚Üí key: $keyName');
    print('üì¶ Total items to save: ${list.length}');

    final box = Hive.box('reminders_box');

    List<String> stringList =
        list.map((item) {
          if (item is Map<String, AlarmSettings>) {
            print('üóÇ Saving Map<String, AlarmSettings>');
            final jsonMap = item.map((key, value) {
              print('   ‚ûú Alarm: $key | id=${value.id}');
              return MapEntry(key, value.toJson());
            });
            return jsonEncode(jsonMap);
          } else if (item is medicine_payload.MedicineReminderModel) {
            print('üíä Saving MedicineReminderModel ‚Üí ${item.title}');
            return jsonEncode(item.toJson());
          } else if (item is WaterReminderModel) {
            print(
              'üíß Saving WaterReminderModel ‚Üí '
              'id=${item.id}, '
              'title=${item.title}, '
              'alarms=${item.alarms.length}, '
              'waterReminderStartTime=${item.waterReminderStartTime}, '
              'waterReminderEndTime=${item.waterReminderEndTime}, '
              'timesPerDay=${item.timesPerDay}',
            );
            return jsonEncode(item.toJson());
          }

          print('‚ö†Ô∏è Unknown item type: ${item.runtimeType}');
          return jsonEncode({});
        }).toList();

    await box.put(keyName, stringList);
    print('‚úÖ Saved ${stringList.length} items to Hive ‚Üí $keyName');
  }

  Future<void> loadAllReminderLists() async {
    try {
      print('üîÑ loadAllReminderLists() START');
      isLoading(true);

      medicineGetxController.medicineList.value = await medicineGetxController
          .loadMedicineReminderList("medicine_list");
      print(
        'üíä Medicine loaded: ${medicineGetxController.medicineList.length}',
      );

      mealController.mealsList.value = await loadReminderList("meals_list");
      print('üçΩ Meals loaded: ${mealController.mealsList.length}');

      eventGetxController.eventList.value = await loadReminderList(
        "event_list",
      );
      print('üìÖ Events loaded: ${eventGetxController.eventList.length}');

      waterController.waterList.value = await waterController
          .loadWaterReminderList("water_list");
      print('üíß Water loaded: ${waterController.waterList.length}');

      final List<reminder_payload.ReminderPayloadModel> combined = [];

      print('üß© Building combined reminder list');

      for (var item in medicineGetxController.medicineList) {
        print('‚ûï Add Medicine ‚Üí ${item.title}');
        print('Description Med: ${item.notes ?? ""}');
        combined.add(
          reminder_payload.ReminderPayloadModel(
            id: item.id,
            category: "Medicine",
            title: item.title,
            whenToTake: item.whenToTake,
            medicineName: item.medicineName,
            dosage: reminder_payload.Dosage(
              value: item.dosage.value,
              unit: item.dosage.unit,
            ),
            medicineType: item.medicineType,
            notes: item.notes,
            medicineFrequencyPerDay: item.medicineFrequencyPerDay,
            customReminder: reminder_payload.CustomReminder(
              timesPerDay: reminder_payload.TimesPerDay(
                count: item.customReminder.timesPerDay?.count ?? '',
                list: item.customReminder.timesPerDay?.list ?? [],
              ),
            ),
          ),
        );
      }

      for (var item in mealController.mealsList) {
        item.forEach((title, alarm) {
          print('‚ûï Add Meal ‚Üí $title | id=${alarm.id}');
          combined.add(
            reminder_payload.ReminderPayloadModel(
              id: alarm.id,
              category: "Meal",
              title: title,
              notes: alarm.notificationSettings.body,
              customReminder: reminder_payload.CustomReminder(
                timesPerDay: reminder_payload.TimesPerDay(
                  count: 1.toString(),
                  list: [alarm.dateTime.toString()],
                ),
              ),
            ),
          );
        });
      }

      for (var item in eventGetxController.eventList) {
        item.forEach((title, alarm) {
          print('‚ûï Add Event ‚Üí $title | id=${alarm.id}');
          print('Description: ${alarm.notificationSettings.body ?? ""}');
          combined.add(
            reminder_payload.ReminderPayloadModel(
              id: alarm.id,
              category: "Event",
              title: title,
              customReminder: reminder_payload.CustomReminder(
                timesPerDay: reminder_payload.TimesPerDay(
                  count: 1.toString(),
                  list: [alarm.dateTime.toString()],
                ),
              ),
              notes: alarm.notificationSettings.body,
            ),
          );
        });
      }

      for (var item in waterController.waterList) {
        print(
          '‚ûï Add Water ‚Üí '
          'id=${item.id}, '
          'title=${item.title}, '
          'alarms=${item.alarms.length}, '
          'start_water_time=${item.waterReminderStartTime}, '
          'end_water_time=${item.waterReminderEndTime}, '
          'timesPerDay=${item.timesPerDay}, '
          'interval=${item.interval}, '
          'type=${item.type.name}',
        );

        final bool isTimesBased = item.type == Option.times;
        final bool isIntervalBased = item.type == Option.interval;

        combined.add(
          reminder_payload.ReminderPayloadModel(
            id: item.id,
            category: "Water",
            title: item.title,
            // ‚úÖ FIXED
            customReminder: reminder_payload.CustomReminder(
              type: item.type, // ‚úÖ FIXED
              timesPerDay:
                  isTimesBased
                      ? reminder_payload.TimesPerDay(
                        count: item.timesPerDay,
                        list: [],
                      )
                      : null,
              everyXHours:
                  isIntervalBased
                      ? reminder_payload.EveryXHours(
                        hours: int.parse(item.interval ?? ''),
                        // SAFE because type enforces it
                        startTime: '',
                        endTime: '',
                      )
                      : null,
            ),
            startWaterTime: item.waterReminderStartTime,
            endWaterTime: item.waterReminderEndTime,
          ),
        );
      }

      reminders.value = combined;
      print('Combined reminders count: ${combined.length}');
    } catch (e, stack) {
      print('‚ùå Error loading reminder lists: $e');
      print(stack);
    } finally {
      isLoading(false);
      print('loadAllReminderLists() END');
    }
  }

  // ==================== API Methods ====================

  Future<void> getReminders(BuildContext context) async {
    try {
      isLoading(true);

      var result = await getReminderFromAPI(context);
      var reminders = result as List<reminder_payload.ReminderPayloadModel>;
      this.reminders.assignAll(reminders);
      print(reminders);
    } catch (e) {
      print("Error fetching reminders");
    } finally {
      isLoading(false);
    }
  }

  Future<dynamic> getReminderFromAPI(BuildContext context) async {
    try {
      final response = await ApiService.post(
        getreminderApi,
        null,
        withAuth: true,
        encryptionRequired: false,
      );

      if (response is http.Response && response.statusCode >= 400) {
        CustomSnackbar.showError(
          context: context,
          title: 'Error',
          message: 'Failed to fetch reminders: ${response.statusCode}',
        );
        return [];
      }

      final enc = jsonEncode(response);
      final decbody = jsonDecode(enc);
      final List remindersList = decbody['data']['Reminders'] as List;
      return remindersList.map((e) => e as Map<String, dynamic>).toList();
    } catch (e) {
      debugPrint("Exception while fetching reminders: $e");

      return [];
    }
  }

  // Future<void> addRemindertoAPI(
  //   reminder_payload.ReminderPayloadModel reminderData,
  //   BuildContext context,
  // ) async {
  //   try {
  //     final response = await ApiService.post(
  //       addreminderApi,
  //       reminderData.toJson(),
  //       withAuth: true,
  //       encryptionRequired: true,
  //     );
  //
  //     print("response addRemindertoAPI $response");
  //
  //     if (response is http.Response && response.statusCode >= 400) {
  //       CustomSnackbar.showError(
  //         context: context,
  //         title: 'Error',
  //         message: 'Failed to save Reminder record: ${response.statusCode}',
  //       );
  //     }
  //     // else {
  //     //   await getReminders(context);
  //     // }
  //   } catch (e) {
  //     debugPrint("Exception while saving Reminder record: $e");
  //   }
  // }

  Future<void> updateReminder(
    reminder_payload.ReminderPayloadModel reminderData,
    BuildContext context,
  ) async {
    try {
      final response = await ApiService.post(
        editreminderApi,
        reminderData.toJson(),
        withAuth: true,
        encryptionRequired: true,
      );

      if (response is http.Response && response.statusCode >= 400) {
        CustomSnackbar.showError(
          context: context,
          title: 'Error',
          message: 'Failed to update Reminder record: ${response.statusCode}',
        );
      }
      // else {
      //   await getReminders(context);
      // }
    } catch (e) {
      debugPrint("Exception while updating Reminder record: $e");
    }
  }

  Future<bool> validateAndSave({
    required BuildContext context,
    num? dosage,
  }) async {
    final isSelected =
        medicineGetxController.medicineRemindMeBeforeOption.value == 0;

    if (isSelected) {
      await handleRemindMeBefore(
        option: medicineGetxController.medicineRemindMeBeforeOption,
        timeOfDay: pickedTime.value,
        timeController: xTimeUnitController,
        unitController: selectedValue,
        category: "Medicine",
        title: "Upcoming Medicine Reminder",
        body: "It‚Äôs almost time to take your medicine in ",
      );
    }
    final isSelectedEvent = eventGetxController.eventRemindMeBefore.value == 0;

    if (isSelectedEvent) {
      await handleRemindMeBefore(
        option: eventGetxController.eventRemindMeBefore,
        timeOfDay: pickedTime.value,
        timeController: xTimeUnitController,
        unitController: selectedValue,
        title: "Upcoming Event Reminder",
        body: "Your scheduled event will start in ",
        category: "Event",
      );
    }

    // üîí Always validate inputs first
    if (titleController.text.trim().isEmpty) {
      Get.snackbar(
        "Almost there",
        "Add a title for your ${selectedCategory.value} reminder",
        snackPosition: SnackPosition.TOP,
        colorText: white,
        backgroundColor: AppColors.primaryColor,
        duration: const Duration(seconds: 2),
      );
      return false;
    }
    if (titleController.text.trim().length >= maxTitleLength) {
      Get.snackbar(
        "Title too long",
        "You can keep the title short and add extra details in Notes",
        snackPosition: SnackPosition.TOP,
        colorText: white,
        backgroundColor: AppColors.primaryColor,
        duration: const Duration(seconds: 2),
      );
      return false;
    }

    final isInterval =
        medicineGetxController.medicineReminderOption.value == Option.interval;

    if (!isInterval) {
      if (pickedTime.value == null) {
        Get.snackbar(
          "Almost there",
          "Pick a time for your ${selectedCategory.value} reminder",
          snackPosition: SnackPosition.TOP,
          colorText: white,
          backgroundColor: AppColors.primaryColor,
          duration: const Duration(seconds: 2),
        );

        return false;
      }
    }

    if (editingId.value != null) {
      updateReminderFromLocal(
        context,
        id: editingId.value,
        category: selectedCategory.value,
        timeOfDay: pickedTime.value!,
      );
      return true;
    }

    if (selectedCategory.value == "Medicine") {
      if (dosage == null || dosage <= 0) {
        Get.snackbar(
          "Oops!",
          "That dosage doesn‚Äôt look right. Please enter a valid one.",
          snackPosition: SnackPosition.TOP,
          colorText: white,
          backgroundColor: AppColors.primaryColor,
          duration: const Duration(seconds: 2),
        );
        return false;
      }
    }

    switch (selectedCategory.value) {
      case "Medicine":
        final isInterval =
            medicineGetxController.medicineReminderOption.value ==
            Option.interval;

        if (!isInterval) {
          final int expectedTimes =
              medicineGetxController.getEffectiveTimesPerDay();

          final int filledTimes =
              medicineGetxController.timeControllers
                  .where((ctrl) => ctrl.text.trim().isNotEmpty)
                  .length;

          if (filledTimes < expectedTimes) {
            final missing = expectedTimes - filledTimes;

            Get.snackbar(
              "Missing time${missing > 1 ? 's' : ''}",
              "You selected '${medicineGetxController.selectedFrequency.value}'. "
                  "Please add $missing more time${missing > 1 ? 's' : ''}.",
              snackPosition: SnackPosition.TOP,
              colorText: white,
              backgroundColor: AppColors.primaryColor,
              duration: const Duration(seconds: 3),
            );

            return false;
          }
        }

        medicineGetxController.addMedicineAlarm(
          context: context,
          dosage: dosage,
        );

        if (medicineGetxController.medicineReminderOption.value ==
            Option.interval) {
          if (medicineGetxController.medicineReminderOption.value ==
              Option.interval) {
            // üîí validate start & end time
            if (medicineGetxController.startMedicineTimeController.text
                    .trim()
                    .isEmpty ||
                medicineGetxController.endMedicineTimeController.text
                    .trim()
                    .isEmpty) {
              Get.snackbar(
                "Missing time",
                "Please select both start and end time for interval reminders.",
                snackPosition: SnackPosition.TOP,
                colorText: white,
                backgroundColor: AppColors.primaryColor,
                duration: const Duration(seconds: 3),
              );
              return false;
            }

            final intervalHours =
                int.tryParse(medicineGetxController.everyHourController.text) ??
                0;

            final startDateTime = startDate.value ?? DateTime.now();
            final endDateTime = endDate.value ?? DateTime.now();

            medicineGetxController.addMedicineIntervalAlarm(
              context: context,
              startDateTime: startDateTime,
              endDateTime: endDateTime,
              dosage: dosage,
              intervalHours: intervalHours,
            );
          }
        }

      case "Meal":
      case "Event":
        addAlarm(
          context,
          timeOfDay: pickedTime.value!,
          category: selectedCategory.value,
        );
        break;

      case "Water":
        waterController.validateAndSaveWaterReminder(context);
        break;

      default:
        print("‚ö†Ô∏è Unknown category: ${selectedCategory.value}");
    }

    return true;
  }

  Future<void> refreshAllData(BuildContext context) async {
    await loadAllReminderLists();
  }

  String getCategoryIcon(String category) {
    switch (category) {
      case 'Medicine':
        return medicineIcon;
      case 'Water':
        return waterReminderIcon;
      case 'Meal':
        return mealIcon;
      case 'Event':
        return eventIcon;
      default:
        return "";
    }
  }

  // Color getCategoryColor(String category) {
  //   return AppColors.primaryColor;
  // }

  void resetForm() {
    titleController.clear();
    timeController.clear();

    // medicineList.clear(); // FIX: Do not clear reminder list on reset
    notesController.clear();
    waterController.resetControllers();

    selectedCategory.value = 'Medicine';
    editingId.value = null; // Clear ID so next add is fresh
    startDate.value = DateTime.now();
    endDate.value = null;
    pickedTime.value = null;
    waterController.waterReminderOption.value = Option.interval;
    //savedInterval.value = 0;

    enableNotifications.value = true;
    soundVibrationToggle.value = true;
    remindTimes.clear();
  }

  void loadReminderData(reminder_payload.ReminderPayloadModel reminder) {
    debugPrint("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ LOAD REMINDER DATA ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
    debugPrint("Reminder ID: ${reminder.id}");
    debugPrint("Title: ${reminder.title}");
    debugPrint("Category: ${reminder.category}");
    debugPrint("Notes: ${reminder.notes}");
    debugPrint("Medicine Name: ${reminder.medicineName}");
    debugPrint("Start Date: ${reminder.startDate}");
    debugPrint("Custom Reminder: ${reminder.customReminder}");

    // Basic fields
    titleController.text = reminder.title ?? '';
    notesController.text = reminder.notes ?? '';
    selectedCategory.value = reminder.category;
    editingId.value = reminder.id;

    debugPrint("‚Üí titleController.text: ${titleController.text}");
    debugPrint("‚Üí notesController.text: ${notesController.text}");
    debugPrint("‚Üí selectedCategory: ${selectedCategory.value}");
    debugPrint("‚Üí editingId: ${editingId.value}");

    // Medicine
    if (reminder.category == 'Medicine') {
      medicineGetxController.medicineController.text =
          reminder.medicineName ?? '';
      debugPrint(
        "‚Üí medicineController.text: ${medicineGetxController.medicineController.text}",
      );
    }

    // Start date (SAFE)
    startDate.value =
        reminder.startDate != null && reminder.startDate!.isNotEmpty
            ? DateTime.tryParse(reminder.startDate!)
            : null;
    debugPrint("‚Üí startDate.value: ${startDate.value}");

    // Water reminder
    if (reminder.category == ReminderCategory.water.name) {
      final custom = reminder.customReminder;
      debugPrint("‚Üí Water reminder custom: $custom");

      if (waterController.waterReminderOption.value == Option.interval) {
        waterController.everyHourController.text =
            custom?.everyXHours?.hours.toString() ?? '';
        debugPrint(
          "‚Üí everyHourController.text: ${waterController.everyHourController.text}",
        );
      }

      if (waterController.waterReminderOption.value == Option.times) {
        waterController.timesPerDayController.text =
            custom?.timesPerDay?.count.toString() ?? '';
        debugPrint(
          "‚Üí timesPerDayController.text: ${waterController.timesPerDayController.text}",
        );
      }
    }
    debugPrint("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ END LOAD REMINDER DATA ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
  }import 'dart:convert';

import 'package:alarm/alarm.dart';
import 'package:alarm/model/notification_settings.dart';
import 'package:get/get.dart';
import 'package:snevva/Controllers/Reminder/reminder_controller.dart';
import 'package:snevva/Controllers/Reminder/water_controller.dart';
import 'package:snevva/generated/l10n.dart';
import 'package:snevva/models/hive_models/reminder_payload_model.dart';
import 'package:snevva/models/water_reminder_model.dart';

import '../../common/global_variables.dart';
import '../../consts/colors.dart';
import '../../consts/images.dart';

class ReminderScheduler {
  static var waterList = <WaterReminderModel>[].obs;
  static var mealsList = <Map<String, AlarmSettings>>[].obs;
  static var eventList = <Map<String, AlarmSettings>>[].obs;

  static Future<void> scheduleAll(List<ReminderPayloadModel> reminders) async {
    for (final reminder in reminders) {
      await _scheduleByCategory(reminder);
    }
  }

  static Future<void> _scheduleByCategory(ReminderPayloadModel reminder) async {
    switch (reminder.category) {
      case 'medicine':
        break;
      case 'water':
        break;
      case 'meal':
        await scheduleReminderFromModel(
          reminder: reminder,
          category: 'meal',
          keyName: "meals_list",
          reminderList: mealsList,
        );
        break;
      case 'event':
        final timesList = reminder.customReminder.timesPerDay?.list ?? [];
        final date = reminder.startDate;
        if (reminder.remindBefore != null && timesList.isNotEmpty) {
          final timeString = timesList.first;
          final mainTime = buildDateTimeFromTimeString(time: timeString);
          schedulePreReminder(
            mainTime: mainTime,
            category: 'event',
            body: "Your scheduled event will start in ",
            reminder: reminder,
          );
        }
        scheduleReminderFromModel(
          reminder: reminder,
          category: 'event',
          date: date,
          reminderList: eventList,
          keyName: "event_list",
        );
        break;
    }
  }

  static int scheduledReminderId({
    required int reminderId,
    required DateTime time,
  }) {
    return reminderId * 100000 + time.hour * 100 + time.minute;
  }

  static Future<void> scheduleWaterReminder({
    required ReminderPayloadModel reminder,
  }) async {
    final customReminder = reminder.customReminder;
    final timesPerDay = customReminder.timesPerDay;
    final times = int.parse(reminder.customReminder.timesPerDay!.count);
    if (timesPerDay != null) {
      final alarmTimes = Get.find<WaterController>().generateTimesBetween(
        startTime: reminder.startWaterTime!,
        endTime: reminder.endWaterTime!,
        times: times,
      );
      List<AlarmSettings> createdAlarms = [];

      for (var i = 0; i < alarmTimes.length; i++) {
        final time = alarmTimes[i];
        final scheduledTime =
        time.isBefore(DateTime.now()) ? time.add(Duration(days: 1)) : time;
        final alarmId = alarmsId();

        final alarmSettings = AlarmSettings(
          id: alarmId,
          dateTime: scheduledTime,
          assetAudioPath: alarmSound,
          volumeSettings: VolumeSettings.fade(
            volume: 0.8,
            fadeDuration: Duration(seconds: 5),
            volumeEnforced: true,
          ),
          notificationSettings: NotificationSettings(
            title: reminder.title,
            body: reminder.notes ?? '',
            stopButton: 'Stop',
            icon: 'alarm',
            iconColor: AppColors.primaryColor,
          ),
        );
        await Alarm.set(alarmSettings: alarmSettings);
        createdAlarms.add(alarmSettings);
      }

      final waterReminderId = DateTime
          .now()
          .millisecondsSinceEpoch;
      final timesPerDayCount = reminder.customReminder.timesPerDay!.count;
      final model = WaterReminderModel(
        id: waterReminderId,
        title: reminder.title,
        category: reminder.category,
        type: Option.times,
        alarms: createdAlarms,
        timesPerDay: timesPerDayCount,
        waterReminderStartTime: reminder.startWaterTime ?? '',
        waterReminderEndTime: reminder.endWaterTime ?? '',
      );
      waterList.value = await Get.find<WaterController>().loadWaterReminderList(
        "water_list",
      );
      waterList.add(model);
      await Get.find<ReminderController>().saveReminderList(
        waterList,
        "water_list",
      );
      await Get.find<ReminderController>().loadAllReminderLists();

      // List<String> list =
      //     createdAlarms.map((e) => e.toJson().toString()).toList();
      //
    }
    final intervalHours = customReminder.everyXHours;
    if (intervalHours != null) {
      final startWaterString = customReminder.everyXHours!.startTime;
      final endWaterString = customReminder.everyXHours!.endTime;
      final startTime = stringToTimeOfDay(startWaterString);
      final endTime = stringToTimeOfDay(endWaterString);
      final intervalHours = customReminder.everyXHours!.hours;
      final reminders = Get.find<WaterController>().generateEveryXHours(
        start: startTime,
        end: endTime,
        intervalHours: intervalHours,
      );
      await Get.find<WaterController>().setIntervalReminders(
          intervalReminders: reminders,
          intervalHours: intervalHours,
          title: reminder.title,
          body: reminder.notes ?? '');
    }
  }

  static Future<void> schedulePreReminder({
    required DateTime mainTime,
    required String category,
    required String body,
    required ReminderPayloadModel reminder,
  }) async {
    final before = reminder.remindBefore!;
    final amount = before.time;
    final unit = before.unit;

    final offset =
    unit == 'minutes' ? Duration(minutes: amount) : Duration(hours: amount);

    DateTime beforeTime = mainTime.subtract(offset);
    if (beforeTime.isBefore(DateTime.now())) {
      beforeTime = beforeTime.add(const Duration(days: 1));
    }
    final alarmSettings = AlarmSettings(
      id: scheduledReminderId(reminderId: reminder.id, time: mainTime),
      dateTime: mainTime,
      assetAudioPath: alarmSound,
      volumeSettings: VolumeSettings.fade(
        volume: 0.8,
        fadeDuration: Duration(seconds: 5),
        volumeEnforced: true,
      ),
      notificationSettings: NotificationSettings(
        title: "Upcoming ${category.capitalizeFirst} Reminder",
        body: "$body $amount $unit",
        stopButton: 'Stop',
        icon: 'alarm',
        iconColor: AppColors.primaryColor,
      ),
      payload: jsonEncode({
        "type": "before",
        "category": category,
        "mainTime": mainTime.toIso8601String(),
      }),
    );
  }

  static Future<void> scheduleReminderFromModel({
    required ReminderPayloadModel reminder,
    required String category,
    required RxList<Map<String, AlarmSettings>> reminderList,
    required String keyName,
    String? date,
  }) async {
    if (reminder.category != category) return;
    final times = reminder.customReminder.timesPerDay?.list;
    if (times == null || times.isEmpty) return;
    for (final time in times) {
      final dateTime = buildDateTimeFromTimeString(time: time, date: date);
      final alarmSettings = AlarmSettings(
        id: scheduledReminderId(reminderId: reminder.id, time: dateTime),
        dateTime: dateTime,
        assetAudioPath: alarmSound,
        volumeSettings: VolumeSettings.fade(
          volume: 0.8,
          fadeDuration: Duration(seconds: 5),
          volumeEnforced: true,
        ),
        notificationSettings: NotificationSettings(
          title: reminder.title,
          body: reminder.notes ?? '',
          stopButton: 'Stop',
          icon: 'alarm',
          iconColor: AppColors.primaryColor,
        ),
      );
      final success = await Alarm.set(alarmSettings: alarmSettings);
      if (success) {
        reminderList.value = await Get.find<ReminderController>()
            .loadReminderList(keyName);

        final displayTitle =
        reminder.title.isNotEmpty
            ? reminder.title
            : '${category.toUpperCase()} REMINDER';
        reminderList.add({displayTitle: alarmSettings});
        await Get.find<ReminderController>().saveReminderList(
          reminderList,
          keyName,
        );
        await Get.find<ReminderController>().loadAllReminderLists();
      }
      // Reload list from Hive to ensure we have the latest data and don't override

      //reminderController.addRemindertoAPI(mealData, context);

      // CustomSnackbar.showSuccess(
      //   context: context,
      //   title: 'Success',
      //   message: 'Meal reminder set successfully!',
      // );
    }
  }
}